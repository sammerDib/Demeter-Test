#ifndef OLOVIA_MAIN
#define OLOVIA_MAIN

#include "Nag_Compatibility.h"
#include "MATRIX.H"

//#define OLOVIA_DEBUG //define for Debug output in Olovia.cpp 

//TD OCT: 
BOOL bReadLiseFile(char szFileName[], double dzStart, double dPeriod, int& iNoPixelsInPeriod, double **ppz, double **ppData, int *iTypeOfHole);  //for OLOVIA Project
BOOL bReadFTFile(int *iNoOfLines, double **ppz, double **ppDataRe, double **ppDataIm);

void vDeltaIntAndDerivForDLS(void *pInfoInt, void *pInfoSpectrum, const Vector& VParam, Vector *pVResult, Matrix *pMResult, bool bOptParam[], bool *pSuc);

void vWeightedAverageAndStdErr(Vector& VStdErr, Vector& VParam, cppc& cAverage, double& dStdDev);

void vLimitTheStepSize(Vector &Vx, Vector &Vs, Vector &VxNext, void *pInfoSpectrum, double &dMu);

struct sSpectro_Data {  //Spectroscopic reflectometry:
	int iNoPoints = 4094;
	double dPeriod, *pzMeasured = NULL, *pIntMeasured = NULL, *pDark = NULL, *pReference = NULL;
	int iNoFFTPoints; dVector *pdVk = NULL; Vector *pVSpectrum = NULL; Vector *pVSpecWindow = NULL; dVector *pdVAbsFT = NULL;
};


bool bRead_Dark_Reference_Sample_And_Summarize_In_One_File(char szFileNameDark[], char szFileNameReference[], char szFileNameSample[],
	char szOutputFileName[], int iNoPoints, double *pWavelength_nm, double *pDark, double *pReference, double *pSpectrum);
bool bReadAvantesFile(const char* szFileName, int iNoPoints, double *pWavelength_nm, double *pDark, double *pReference, double *pSpectrum);
void vFT_of_Spectro(struct sSpectro_Data *p);
BOOL bReadFFTResultFile(char szFile1[], char szFile2[], char szFile3[], char szFile4[], char szFile5[]);


class LISE_HF_Dir_Space {
public:
	bool bUpdateWeights = false; 
	int iDim_z = 0, iStart = 0, iStop = 0;  
	double *pdStaticWeights = NULL, *pdDynamicWeights = NULL, *pdWeightsInTotal = NULL, dSumOfWeights = 0.0; 
	double *pdCosine = NULL, *pdWeightsSinglePeak = NULL; //used as temporary memory to avoid continuous alloc. and dealloc. 
	double dAmpl_TSV_Si_Init = 0.0, dDelta_z = 0.0;  //double dAmpl_Multilayer_Init;  double dAmplitude_TSV_Top_Init; 
	//We consider the initial amplitudes of the signal S(z) before starting damped least squares: There are up to 3 amplitudes to be fitted: 
	//Amplitude of the peak belonging to the multilayer without TSV (that's on the left); Amplitude of the peak generated by the TSV bottom and the silicon interface;  
	//Amplitude of the peak generated by the TSV bottom and the interface to the air;  
	LISE_HF_Dir_Space(int iStart_input = 0, int iStop_input = 0, double dDelta_z_input = 0.0, double *pdStaticWeightsInput = NULL) {
		iDim_z = iStop_input - iStart_input + 1;   dDelta_z = dDelta_z_input;
		pdStaticWeights = new double[iDim_z],  pdDynamicWeights = new double[iDim_z],  pdWeightsInTotal = new double[iDim_z];
		pdCosine = new double[iDim_z],  pdWeightsSinglePeak = new double[iDim_z];
		fill(pdCosine, pdCosine + iDim_z, 0.0),  fill(pdWeightsSinglePeak, pdWeightsSinglePeak + iDim_z, 0.0);
		fill(pdDynamicWeights, pdDynamicWeights + iDim_z, 0.0);  //#include <algorithm>   
		if (pdStaticWeightsInput == NULL) { 
			fill(pdStaticWeights, pdStaticWeights + iDim_z, 0.0);    //#include <algorithm> 
			fill(pdWeightsInTotal, pdWeightsInTotal + iDim_z, 0.0);
		}
		else {
			memcpy(pdStaticWeights, pdStaticWeightsInput + iStart_input, iDim_z * sizeof(double));    dSumOfWeights = 0.0;
			for (int i = 0; i < iDim_z; i++)
				dSumOfWeights += pdStaticWeights[i]; 
			for (int i = 0; i < iDim_z; i++)
				pdWeightsInTotal[i] = pdStaticWeights[i] / dSumOfWeights;
		}
		iStart = iStart_input, iStop = iStop_input; 
	}; 
	~LISE_HF_Dir_Space() { 
		delete[] pdStaticWeights;  pdStaticWeights = NULL;   delete[] pdDynamicWeights;  pdDynamicWeights = NULL;  delete[] pdWeightsInTotal;  pdWeightsInTotal = NULL;
		delete[] pdCosine; pdCosine = NULL;  delete[] pdWeightsSinglePeak; pdWeightsSinglePeak = NULL;
		iDim_z = 0; };
};


class sAdditionalData_LISE_ED {
public:
	LISE_HF_Dir_Space *pDirSpace = NULL;
	double dFWHM_Peak; //full width of half maximum 
	sAdditionalData_LISE_ED(LISE_HF_Dir_Space *pDirSpace_Input, double dFWHM_Peak_Input) {
		pDirSpace = pDirSpace_Input, dFWHM_Peak = dFWHM_Peak_Input;
	};
	~sAdditionalData_LISE_ED() { pDirSpace = NULL; };
};


class Multilayer {
public:
	Vector VRef_Ind;
	dVector dVAmplFresnel, dVAttenuationInLayers, dVAttenuationAtInterfaces;
	double dFresnel_rtrt, dAttenuation_total, dLambda_Center = 0.560;
	Multilayer(int iNoInterfaces = 0) {
		VRef_Ind.Nown = iNoInterfaces + 1;   if (VRef_Ind.Data != NULL) delete[] VRef_Ind.Data;   VRef_Ind.Data = new cppc[VRef_Ind.Nown];
		VRef_Ind = 1.0;
		dVAmplFresnel.Nown = iNoInterfaces;  if (dVAmplFresnel.Data != NULL) delete[] dVAmplFresnel.Data;  dVAmplFresnel.Data = new double[dVAmplFresnel.Nown];
		dVAmplFresnel = 0.0;
		dFresnel_rtrt = 1.0;  dAttenuation_total = 1.0;
		dVAttenuationInLayers.Nown = iNoInterfaces - 1;
		if (dVAttenuationInLayers.Data != NULL) delete[] dVAttenuationInLayers.Data;  dVAttenuationInLayers.Data = new double[dVAttenuationInLayers.Nown];
		dVAttenuationInLayers = 1.0;
		dVAttenuationAtInterfaces.Nown = iNoInterfaces;
		if (dVAttenuationAtInterfaces.Data != NULL) delete[] dVAttenuationAtInterfaces.Data;  dVAttenuationAtInterfaces.Data = new double[iNoInterfaces];
		dVAttenuationAtInterfaces = 1.0;
	};
};


class Fresnel_TSV {
public:
	double dEffective_Index_TSV = 1.0;
	double dLambda_Center = 0.560;
	class Multilayer *pMulti = NULL;  //multilayer on top
	Fresnel_TSV(Multilayer Multi) {
		dEffective_Index_TSV = 1.0;
		dLambda_Center = Multi.dLambda_Center;
		pMulti = &Multi;
	};
};


void vLISE_HF_main(double dTSV_diam, int iNo_layers, double *pOptical_thicknesses, double *pOptical_thickness_tolerances, double *pRef_index_re, double *pRef_index_im,
	int iNo_pixels, double *pWavelength_nm, double *pDark_spectrum, double *pReference_spectrum, double *pSpectrum, double *pSpectrumPlanarLayers, int &iFT_dim,
	int iOperating_Mode, bool bPeakDetectionOnRight, bool bNewPeakDetection,  
	double dThreshold_valid_signal, double dThreshold_peak, double dz_Resolution, bool bDebugOutput, int iDebugFileNo,
	double &dAsymptStdErr, double &dNormalizedResidual, double &dQuality, stringstream *pssMessages, double *pModulus_of_FT, double *pz,
	int &iNo_detected_peaks, double *pComputed_optical_thicknesses, double *pAmplitudes_of_peaks, double *pComputed_geom_thicknesses,
	bool &bFT_done, bool &bSignal_analysis_done, double& dMaxPeakFFTAmplitudeinWindow);

void vAverageAndStandardDev();
void vCalcContrastAtSiLayer();


bool bCharacterizeSpectrum(int iNoPixels, double *pdWavelength, double *pdDark, double *pdReference,
	double &dAverageWavelength, double &dRelativeSpectralBroadness, double &dAverageWavelengthEquidistSampl, double &dRelativeSpecBroadnessEquidistSampl);
bool bRead_FPMS_Camera_image(char *szFileName, int &iNoLines, int &iNoColumns, int **ppIntensityImage, char szAdditional_message[], int iNo_char);

bool bEvaluateArrayTestOn_35553_Grid(double dStepSize, double *pdTSV_Depth, double dStandardStepSize,
	double &dAverage, double &dGrad_45_deg, double &dGrad_135_deg, double &dModulusOfGrad, double &dDefocus);
bool bBeamProfiler(int iNoLines, int iNoLinesSub, double dPixelSize_y, int iNoColumns, int iNoColumnsSub, double dPixelSize_x, int *piImage,
	double *pdImageSub, double &dAmpl, double &dxGauss, double &dyGauss, double &dRadius, double &dBackground, double dMaxIntensity, double &dNorm, double &dWeightedNorm,
	double &dRatioOfAxisOfEllipse, double &dAngleOfEllipse);

#define MIN_PERMITTED_AVERAGE_POWER_PER_PIXEL 	100 
#define MAX_PERMITTED_POWER_PER_PIXEL 		65535 

#define FT_ONLY_MODE		0  //only the FFT is returned, not the complete signal analysis; This replaces "FFT_MODE". 
#define GRID_SEARCH_MODE	2  //model-based signal analysis 

#define NO_OF_WAVELENGTHS	21
#define NO_OF_DIAMETERS		100 

#define PLANAR		-1
#define ONE_DIM_TE	0 
#define ONE_DIM_TM	1
#define CIRC		2   


#define MU_START_DLS_LISE 0.15 //DLS: damped least squares
#define MU_START_DLS_LISE_DIAM 10.0 
#define TOLERANCE_DLS 1.0e-5 
#define CHANGE_OF_DLS_RESIDUAL 1.0e-6 //one criterion for stopping the Damped Least Squares Algorithm 
#define MAX_ITER_DLS 300 

#define AMPL_TOP_LISE	0 //entry number of parameter array for damped least squares
#define AMPL_RE_TOP_LISE	0 
#define D_TOP_LISE		0 
#define Z_TOP_LISE		1 
#define AMPL_BOT_LISE	2 
#define AMPL_RE_BOT_LISE	2
#define D_BOT_LISE		2  
#define Z_BOT_LISE		3 
#define DEPTH_LISE		3 //"depth" is the better alternative to z_bottom
#define PHASE_TOP_LISE	4
#define AMPL_IM_TOP_LISE	4
#define	PHASE_BOT_LISE	5 
#define AMPL_IM_BOT_LISE	5 

#define NO_WEIGHTS 0
#define WEIGHTS_IN_FOURIER_SPACE 1
#define WEIGHTS_IN_DIRECT_SPACE  2

#define C_AMPL_TOP_LISE 0
#define C_AMPL_BOT_LISE 1  

#define Z_SCALE		1.0 //22.0 //1.0 //scaling factor to have matrix entries of the same order of magnitude in derivatives for damped least squares  

#define STEP_SIZE_D 0.05 

#define COEFF_EH	 0 
#define COEFF_TH	 1 
#define COEFF_EB_RB  2
#define COEFF_EB_RH  3 

#define X5_OBJ	 5
#define X10_OBJ	 10
#define X20_OBJ	 20
#define X50_OBJ	 50

//For LISE-HF in 2021:
#define DEPTH_TSV	0 
#define AMPL_TSV	1
#define FWHM_TSV			2
#define BACKGROUND			3
#define DERIV_BACKGROUND	4
#define AMPL_LAYERS_TOP		5 
//#define HALF_WIDTH_PEAK_Layers 4  
#define MAX_DETECTABLE_DEPTH 200.0 //in µm
#define MIN_TSV_DIAMETER 1.9 //in µm
#define MIN_NO_PIXELS 2048 
#define MIN_DIM_MESSAGES 128 

#define OLOVIA_MAIN
#endif 